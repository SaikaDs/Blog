摘要
> 行为树通过优先级和中断机制，可以提供比状态机更灵活的AI行为控制。本文总结了从零开始建立一套行为树框架的实践过程。这个框架提供了"选择-执行"的基本循环，和"监听-中断"的基本机制；在这个框架的基础上，怪物AI子类可通过编写脚本来快速构建行为树和动作节点。整个行为树通过Unity的协程系统实现，确保了异步代码高度模块化，可扩展性强，且清晰易读。

# 背景
旧的敌人AI是状态机结构的，代码不清晰直观，难以区分动作优先级，且不利于扩展。有必要迭代成行为树结构。一般意义上，行为树为了便于策划配置，通常是可视化的、高度模块化的，并且Unity已经有很多支持这些功能的行为树插件了。但为了学习（省钱），还是自己造轮子，构建了一个纯脚本的行为树框架。  

以前的敌人AI状态机有以下几种状态  
Wait：追逐玩家，直到接近到一定距离，进入Alert  
Alert：选择"攻击"或者"一边防御一边横移踱步"，如果是攻击，进入Alert  
Attack：攻击，硬直时间后返回Wait  
Beat：招架或受击时，强制转入该状态，硬直时间后返回Wait  
现在想要加入一个"闪避"动作，如果逻辑加在Alert状态中，会导致Alert状态要同时支持"防御"和"闪避"两种动作，失去了状态的特性；而如果要增加一个"闪避"状态，除了要迭代框架，增加一个状态，还要面临框架的复用性问题：毕竟别的敌人可能没有"闪避"这个动作。  
由此可见状态机的局限性
# 行为树与状态机
行为树最大的特征是有```层次分明的优先级```，它从根节点开始，根据环境和自身状态，通过一系列的选择节点后，选择到"叶子结点"，并执行该节点所对应的动作。对于敌人的AI，行为树应该被置于一个无限的循环中，以一定的规则重复地进行选择和执行。有很多种循环方法，比如每帧都评估行为树，但大多数时候，都会追溯到同一个叶子结点（也就是当前running的节点）；或者在running时不进行评估，只在动作执行完后再进行下一次从根开始的评估。
> 行为树与状态机其实是类似的，每个叶子结点就相当于一个状态。只是状态直接的跳转不是由状态自身的转换条件决定，而是由树的结构、循环、中断机制决定的。因此，在状态/叶子结点较多时，行为树可以省去很多重复的转换条件代码，更有利于扩展
# 行为树设计
### 循环机制
究其根本，支撑行为树运转的核心循环如下：
<center>
<img src="images/%E8%A1%8C%E4%B8%BA%E6%A0%91/1.png" width=350>
</center>

这个简单的循环概括了行为树最核心的逻辑：选择->执行。它可以做到"根据环境条件选择行为->执行行为->执行完毕->重新选择行为"这样的简单逻辑。  
进一步，另一个重要的部分是中断机制。稍微完善一下：
<center>
<img src="images/%E8%A1%8C%E4%B8%BA%E6%A0%91/2.png" width=350>
</center>

可以看到增加了一种循环路径（蓝色路径），这种情况对应事件中断的情况。其中，在选择行为的过程中，会添加一至多个必要的事件监听。当持续执行动作的期间如果监听到了事件，则立即中断执行，进入下一个循环。  
其中，为了状态周期的完备性，为每个动作增加了一个动作回收环节，它无论是正常执行完动作或者是中断动作，都会被调用。  
另外，通过事件中断时，会添加对应的信号到"黑板"，影响下一次的选择行为。  

> 黑板：
> 行为树脚本中，所有行为判断所需的状态变量的集合，例如"刚进行过一次攻击"，"刚从受击中恢复"等

**例如**
 一个"防御"动作包含以下内容：
 1. 进入动作前，添加一个监听，监听到"受击"事件时
 2. 进入动作时，为游戏对象添加一个DefenseFlag，它标志受到攻击时，可以招架该攻击
 3. 监听到"受击"事件时，
       1. 立即中断防御动作，
       2. 触发动作回收，将DefenseFlag置为False（如果没有这个回收，会产生后续DefenseFlag一直生效的bug）
       3. 向"黑板"添加一个"招架"信号

 动作结束后，在下一个循环的选择行为阶段，因为存在"招架"信号(优先级较高)，选择播放"招架动作"。这样就实现了"防御"时"招架"攻击的动作和逻辑过渡

### 行为树选择

在"选择行为"阶段中，将以预设好的优先级、层次结构，根据当前环境、状态，进行一系列概率判断，并最终选择、返回一个具体的动作来执行。其中，在每个选择层级上，可能添加一个或多个事件监听。

下图展示选择"踱步防御"的例子

<center>
<img src="images/%E8%A1%8C%E4%B8%BA%E6%A0%91/3.png" width=750>
</center>


# 代码实现
秉持着最简单、非可视化、编程友好的原则设计了一个简易的行为树框架。  
上面的循环机制，在时间上，一个循环周期内包含了一瞬间的行为选择、添加监听等逻辑和持续一段时间的动作执行。在Unity中，可以利用协程将这一系列异步的过程编写在同一个while结构体里，使代码清晰易读
### 主循环
```C#
IEnumerator MainCycle()
{
    while (true)
    {
        curAction = StartCoroutine(RunBehavior());      //选择行为
        ClearTrigger();
        yield return new WaitWhile(() => inAction);     //执行动作
        ClearListener();
        onActionEnd?.Invoke();
        onActionEnd = null;
    }
}
```
- MainCycle是行为树运行的主循环，只要AI生效中，它就会一直运行
- RunBehavior是对应"选择行为"的方法，它返回一个子协程方法(IEnumerator)，代表着当前将要运行的动作，并立即开始执行这个"动作子协程"
- "动作子协程"开始后，主循环通过yield return语句等待它执行完毕（通过inAction标志位判断）
- 无论是"动作子协程"被打断，还是自然执行完，inAction标志位都会改变，恢复主循环
- ClearTrigger和ClearListener分别对应信号和事件监听的清除
- onActionEnd对应动作回收环节，每个循环周期都会调用一次

### 行为树选择
RunBehavior方法对应行为树选择，为了统一设置inAction标志位，这里再嵌套了一层协程。
```C#
IEnumerator RunBehavior()
{
    inAction = true;
    yield return ChooseBehavior();
    inAction = false;
}

//由子类实现具体选择逻辑
protected abstract IEnumerator ChooseBehavior();
```
> **协程嵌套**
> 协程是可以嵌套的，具体方式就是在父协程中yield return子协程，具体有两种写法
> 1. 直接yield return 子协程方法
>   yield return ChildFunc();
> 2. 先开启子协程，然后yield return子协程对应的Coroutine对象
>   Coroutine child = StartCoroutine(ChildFunc());
>   yield return child;
> 
> 第二种方法表面看上去，当外界调用StopCoroutine(child)强制结束子协程，可以恢复父协程的运转，但经过测试，实际上父协程会永久卡死。这可能是Unity尚未解决的bug或缺陷，我的Unity版本是2022.1.20f1  
> 因此这里采用了嵌套的方法，用inAction标志位来控制父循环的恢复

### 中断机制
```C#
protected void Interrupt()
{
    if (!inAction) return;
    if (curAction is not null) StopCoroutine(curAction);
    inAction = false;
}
```
Interrupt方法利用StopCoroutine中断当前动作的协程，然后设置inAction标志位，使主循环恢复。

```C#
protected bool CheckListener(AIEventType e)
{
    if (listenerList.Contains(e))
    {
        Interrupt();
        AddTrigger(e);
        return true;
    }
    else
    {
        return false;
    }
}
```
事件触发时会调用CheckListener，它检查是否有对应事件注册，如果有则调用Interrupt方法以中断动作，并添加信号，影响下一次行为的选择。

### 行为树选择方法实例
行为树映射到代码上，其实就是一系列的if else嵌套，在非可视化的行为树编辑上，编写if else代码就是最直观的。
```C#
//行为树
protected override IEnumerator ChooseBehavior()
{
    AddListener(AIEventType.Beat);  //添加受击监听
    AddListener(AIEventType.Defense);  //添加格挡监听
    if (CheckTrigger(AIEventType.Beat))  //检查是否有受击信号
    {
        return PerformBeat();  // 受击动作
    }
    if (CheckTrigger(AIEventType.Defense))  //检查是否有格挡信号
    {
        return PerformDefense();  //格挡动作
    }

    if (targetDistance > alertDistance)  //距离是否大于警戒距离
    {
        return Chase();  //追逐动作
    }
    else
    {
        if (Random.value < desire)  //根据攻击欲望的概率判定
        {
            return Attack();  //攻击动作
        }
        else
        {
            if (Random.value < dodgeDesire)  //根据闪避欲望的概率判定
            {
                return Dodge();  //闪避
            }
            else
            {
                return DefensePace();  //防御踱步
            }
        }
    }
}

//动作：踱步防御
IEnumerator DefensePace()
{
    onActionEnd += () => self.defenseFlag = false;  //添加回收方法，还原flag
    self.defenseFlag = true;  //设置防御flag

    //播放防御踱步动画，持续一定的时间
    bool to_right = Check(0.5f);
    float time = Random.Range(1.5f, 2.0f);
    animator.CrossFade("DefenseBlendTree", 0.2f);
    animator.SetFloat("input_x", to_right ? 1 : -1);
    animator.SetFloat("input_y", 0);
    for (float timer = time; timer > 0; timer -= Time.deltaTime)
    {
        self.SmoothRotateToTarget();
        transform.Translate(transform.right * self.alertSpeed * Time.deltaTime * (to_right ? 1 : -1), Space.World);
        yield return null;
    }
}
...
```