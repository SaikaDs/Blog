# 背景
循环列表是为了在UI中高效地显示大量数据，同时优化性能和内存使用的一种设计理念。  
对于一个滚动列表，如Unity中的ScrollRect，cocos中的ListView，其实际内容往往比视口区域要多得多。视口外的UI元素一般不会被玩家看到，但它们依然存在。当列表内容很多时，这些不可见的UI元素意味着显著的性能浪费。  
循环列表通过回收不可见的UI元素，并在滚动到新区域时，动态创建新的UI元素，来保证只在可见区域中加载数量较少的UI元素，并由此节省性能和内存。  
Unity本身没有提供内置的循环列表组件，本文在ScollRect的基础上，用自定义脚本实现了循环列表。
# 原理
### ScrollRect
Unity的官方组件ScrollRect的核心由一个视口(viewport)和一个内容对象(content)组成。viewport作为父级，通常情况下位置固定，携带一个mask，在自身范围外的content会被遮挡；content作为子级，可以拖拽滑动。由此实现滚动列表。
### 数据-视图
数据和视图分离是循环列表的基础。  
对于数据，维护一份全量数据列表，以及两个int型游标indexMin和indexMax，用于指示当前视口中需要渲染显示的数据项的最小和最大序号。  
对于视图，维护一个对象池，用于UI元素的回收和重用。  
视图的摆放：每一个UI元素被重用时，都要根据其对应数据的序号，设置到指定的位置（几行几列）。
### 探测机制
为了确定何时回收、重用UI元素，设计了两个探测区域。  

**下探区域**
1. ```高度```=UI元素高度+间隙宽度
2. ```位置```总是与最下方(index最大)的UI元素中心对齐
3. 当它的```下边缘```进入视口后（通常是向下滚动时触发），触发加载，将新的一行数据纳入（即indexMax增加一行的数量），并创建新的一行UI元素到最下方。然后更新下探区域自身的位置到新的一行（下移）
4. 当它的```上边缘```退出视口后（通常是向上滚动时触发），触发回收，将最下面的一行数据回收（即indexMax减少一行的数量），并回收最下面一行UI元素。然后更新下探区域自身的位置到新的一行（上移）

**上探区域**
1. ```高度```=UI元素高度+间隙宽度
2. ```位置```总是与最上方(index最小)的UI元素中心对齐
3. 当它的```上边缘```进入视口后（通常是向上滚动时触发），触发加载，将新的一行数据纳入（即indexMin减小一行的数量），并创建新的一行UI元素到最上方。然后更新上探区域自身的位置到新的一行（上移）
4. 当它的```下边缘```退出视口后（通常是向上滚动时触发），触发回收，将最下面的一行数据回收（即indexMin减少一行的数量），并回收最下面一行UI元素。然后更新下探区域自身的位置到新的一行（上移）

<center>
<img src="images/%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8/1.png" width=600>
</center>

**content的尺寸**
由于content的锚点是在最顶部（对于一般的向下滚动的列表来说），增加content的高度时，它的位置不会变化，而向下延伸。因此在下探区域触发加载和回收时，分别增加/减少content的高度即可实现自然地向下滚动。上探区域触发加载和回收时，无需修改content的高度。

# 实现细节
### 抽象类
将循环列表的核心逻辑提取到抽象基类中，抽离UI元素的功能和具体数据结构，交由子类实现。  
父类：只持有数据数量，UI元素预制体；利用游标和探测机制实现完全的循环列表核心功能
子类：实现父类提供的抽象方法，将数据实际设置到UI元素中。向外界提供设置数据列表的接口，自身保存数据列表，并将数据数量设置到父类中。

# 效果
- 绿色为上探区域
- 蓝色为下探区域
- 为了方便展示，禁用了viewport的mask
- 右侧能看出UI资源的回收和重用

<center>
<img src="images/%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8/GIF2.gif" width=600>
</center>